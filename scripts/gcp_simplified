#!/bin/bash

# Aide rapide
for arg in "$@"; do
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        echo "Commit helper with auto-message generation via DeepSeek API, options: [-f|--force] [-p|--passtest] [-h|--help]"
        exit 0
    fi
done

# Charger les variables d'environnement locales
if [ -f .env ]; then
    set -a
    source .env
    set +a
fi

if [ -f .env.local ]; then
    set -a
    source .env.local
    set +a
fi

# Fonction d'aide
function show_usage() {
    printf "Usage: %s [options] [commit_message]\n" "$0"
    printf "\n"
    printf "Options:\n"
    printf "  -f, --force     Force push even if no changes\n"
    printf "  -p, --passtest  Skip tests\n"
    printf "  -h, --help      Show this help\n"
    printf "\n"
    printf "If no commit_message is provided and DEEPSEEK_API_KEY is set,\n"
    printf "an automatic commit message will be generated using DeepSeek.\n"
}

# Variables
force=0
passtest=0
message=""

# Modèle DeepSeek fixe (pas de vérification)
DEEPSEEK_MODEL="deepseek-chat"

# Parsing des options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --force|-f)
            force=1
            shift
            ;;
        --passtest|-p)
            passtest=1
            shift
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            # Option inconnue, ignorer
            shift
            ;;
        *)
            # Premier argument non-option = message
            message="$1"
            shift
            break
            ;;
    esac
done

# Si d'autres arguments après, les concaténer au message
if [[ $# -gt 0 && -z "$message" ]]; then
    message="$*"
fi

# Si pas de dossier tests, passer les tests automatiquement
if [ ! -d "tests" ]; then
    passtest=1
fi

# Vérifier s'il y a des modifications ou si on force
if [[ $(git status --porcelain) ]] || [ $force -eq 1 ]; then
    # Exécuter les tests si demandé
    if [ -f bin/phpunit ] && [ $passtest -eq 0 ]; then
        echo "Running tests"
        CURRENT=$(pwd)
        BASENAME=$(basename "$CURRENT")
        docker exec -it "$BASENAME" bin/phpunit
        
        if [ $? -ne 0 ]; then
            echo "ERREUR DANS LES TESTS ARRET"
            exit 1
        fi
    fi
    
    # Ajouter tous les fichiers
    git add .
    
    # Générer un message si aucun fourni
    if [ -z "$message" ]; then
        # Utiliser l'API DeepSeek si la clé est disponible
        if [ -z "$DEEPSEEK_API_KEY" ]; then
            echo "DEEPSEEK_API_KEY n'est pas définie. Veuillez fournir un message de commit :"
            read -r message
            if [ -z "$message" ]; then
                echo "Aucun message fourni, abandon."
                exit 1
            fi
        else
            # Générer le diff
            DIFF=$(git diff --cached)
            if [ -z "$DIFF" ]; then
                DIFF=$(git diff)
            fi
            if [ -z "$DIFF" ]; then
                echo "Aucune modification détectée."
                exit 1
            fi
            
            # Simplifier le diff si trop de suppressions
            SUPPR_COUNT=$(echo "$DIFF" | grep -E '^delete mode|^rename ' | wc -l)
            if [ "$SUPPR_COUNT" -gt 10 ]; then
                DIRNAME=$(basename "$PWD")
                echo "[AVERTISSEMENT] Beaucoup de suppressions/déplacements détectées ($SUPPR_COUNT)."
                DIFF="Suppression ou déplacement massif dans le répertoire : $DIRNAME"
            fi
            
            # Tronquer le diff si trop volumineux
            MAX_DIFF=20000
            if [ ${#DIFF} -gt $MAX_DIFF ]; then
                echo "[AVERTISSEMENT] Le diff est trop volumineux, tronqué à $MAX_DIFF caractères."
                DIFF="${DIFF:0:$MAX_DIFF}\n[...diff tronqué...]"
            fi
            
            echo "Génération du commit par DeepSeek (modèle: $DEEPSEEK_MODEL)..."
            
            # Préparer la requête
            PROMPT="Donne un commit git au format {\"title\":\"...\",\"body\":\"...\"} pour ce diff (max 100 tokens). Réponds uniquement par un objet JSON, rien d'autre. Diff: $DIFF"
            
            # Créer un fichier temporaire pour la requête JSON
            TMP_JSON=$(mktemp)
            jq -n \
                --arg model "$DEEPSEEK_MODEL" \
                --arg prompt "$PROMPT" \
                '{
                    "model": $model,
                    "messages": [{"role": "user", "content": $prompt}]
                }' > "$TMP_JSON"
            
            # Envoyer la requête à l'API DeepSeek
            response=$(curl -s -X POST https://api.deepseek.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $DEEPSEEK_API_KEY" \
                --data-binary "@$TMP_JSON")
            
            rm -f "$TMP_JSON"
            
            # Vérifier la réponse
            if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
                error_msg=$(echo "$response" | jq -r '.error.message // "Unknown error"')
                echo "Erreur DeepSeek: $error_msg"
                echo "Veuillez fournir un message de commit :"
                read -r message
                if [ -z "$message" ]; then
                    echo "Aucun message fourni, abandon."
                    exit 1
                fi
            else
                # Extraire le contenu de la réponse
                content=$(echo "$response" | jq -r '.choices[0].message.content')
                
                # Nettoyer et extraire le JSON
                clean_content=$(echo "$content" | sed 's/```json//g; s/```//g' | tr -d '\n')
                json_commit=$(echo "$clean_content" | grep -o '^{.*}$' || echo "$clean_content")
                
                # Extraire titre et corps
                commit_title=$(echo "$json_commit" | jq -r '.title // ""')
                commit_body=$(echo "$json_commit" | jq -r '.body // ""')
                
                if [ -n "$commit_title" ] && [ "$commit_title" != "null" ]; then
                    message="$commit_title"
                    if [ -n "$commit_body" ] && [ "$commit_body" != "null" ]; then
                        message=$(printf "%s\n\n%s" "$commit_title" "$commit_body")
                    fi
                    echo "Message de commit généré : $commit_title"
                else
                    echo "Erreur: Impossible d'extraire le message de commit."
                    echo "Veuillez fournir un message de commit :"
                    read -r message
                    if [ -z "$message" ]; then
                        echo "Aucun message fourni, abandon."
                        exit 1
                    fi
                fi
            fi
        fi
    fi
    
    # Faire le commit
    git commit -m "$message"
    
    # Mettre à jour les sous-modules
    git submodule foreach "git add . && git commit -m '$message'"
    
    # Pousser les changements
    git push --all
    git push --tags
else
    echo "no modifs ;-)"
fi
