#!/bin/bash
for arg in "$@"; do
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        echo "\"Automatically adds/updates shebang and help (-h/--help) blocks in bash scripts, parameters: script files...\""
        exit 0
    fi
done




# Check if any arguments are provided
if [ $# -eq 0 ]; then
    echo "Usage: $0 [script files...]"
    exit 1
fi

# Load .env.local only from ~/debs or ~/git/debs (never local)
if [ -f "$HOME/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/debs/.env.local" | xargs)
    elif [ -f "$HOME/git/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/git/debs/.env.local" | xargs)
fi

# Iterate over all provided files
for script in "$@"; do
    echo "[DEBUG] Processing $script..."
    # Check if it's a file
    if [[ -f "$script" ]]; then
        echo "[DEBUG] $script is a file"
        # Check and add shebang if necessary
        shebang=$(head -n 1 "$script")
        if [[ ! "$shebang" =~ ^#!/bin/(ba|z|)sh ]]; then
            echo "[INFO] $script does not have a bash/sh shebang on the first line. Automatically adding '#!/bin/bash'." >&2
            tmpfile=$(mktemp)
            echo '#!/bin/bash' > "$tmpfile"
            cat "$script" >> "$tmpfile"
            mv "$tmpfile" "$script"
            chmod +x "$script"
            echo "[INFO] Shebang added to $script."
            shebang='#!/bin/bash'
        fi
        echo "[DEBUG] Shebang of $script: $shebang"
        # Si c'est un script bash/sh/zsh, le rendre exécutable
        if [[ "$shebang" =~ ^#!/bin/(ba|z|)sh ]]; then
            if [[ ! -x "$script" ]]; then
                chmod +x "$script"
                echo "[INFO] $script rendu exécutable (chmod +x)"
            fi
            echo "[DEBUG] Valid shebang for $script"
            
            # Toujours supprimer les anciens blocs -h/--help (multi-lignes et une ligne)
            tmpfile=$(mktemp)
            awk 'BEGIN{skip=0}
                # Multi-ligne: for arg in "$@"; do ... if [[ "$arg" == "-h" ... fi ... done
                /^for arg in \"\$@\"; do/ {block=NR;}
                skip==0 && /^\s*for arg in \"\$@\"; do/ {skip=1; printnext=0; next}
                skip==1 && /\s*if \[\[ \"\$arg\" == "-h"/ {printnext=0; next}
                skip==1 && /\s*echo / {printnext=0; next}
                skip==1 && /\s*exit 0/ {printnext=0; next}
                skip==1 && /\s*fi/ {printnext=0; next}
                skip==1 && /\s*done/ {skip=0; next}
                /for arg in \"\$@\"; do if \[\[ \"\$arg\" == "-h"/ {next}
                # Ancienne version: if [[ "$1" == "-h" ... fi
                /^if \[\[ \"\$1\" == "-h"/ {skip=2; next}
                skip==2 && /fi/ {skip=0; next}
            skip==0 {print}' "$script" > "$tmpfile"
            mv "$tmpfile" "$script"
            echo "[INFO] Tous les anciens blocs -h supprimés de $script"
            
            # Ajout du bloc -h
            if [[ -n "$DEEPSEEK" ]]; then
                TMP_JSON=$(mktemp)
                prompt="Provide only a very short one-line description for this bash script (for the -h option), also listing possible parameters. Provide nothing else."
                script_content=$(sed ':a;N;$!ba;s/\n/\\n/g;s/\"/\\\"/g' "$script")
                jq -n --arg prompt "$prompt" --arg content "$script_content" '{
                    model: "deepseek-chat",
                    messages: [
                        {role: "system", content: "You are an assistant that generates help for bash scripts."},
                        {role: "user", content: ($prompt + "\n" + $content)}
                    ]
                }' > "$TMP_JSON"
                helptext=$(curl -s -X POST https://api.deepseek.com/v1/chat/completions \
                    -H "Content-Type: application/json" \
                    -H "Authorization: Bearer $DEEPSEEK" \
                --data-binary "@${TMP_JSON}" | jq -r '.choices[0].message.content')
                rm -f "$TMP_JSON"
                if [[ -z "$helptext" || "$helptext" == "null" ]]; then
                    helptext="Script $script: utility script (add a description here)"
                fi
                elif command -v deepseek &>/dev/null; then
                helptext=$(deepseek --prompt "In one line, provide a very short description of this bash script for the -h option, also listing possible parameters." "$script" 2>/dev/null)
                if [[ -z "$helptext" ]]; then
                    helptext="Script $script: utility script (add a description here)"
                fi
            else
                helptext="Script $script: utility script (add a description here)"
            fi
            
            tmpfile=$(mktemp)
            # Échappe les guillemets doubles dans le helptext pour éviter les erreurs de syntaxe
            safe_helptext=$(echo "$helptext" | sed 's/\"/\\\"/g')
            # Place le -h block juste après le shebang
            {
                echo "$shebang"
                echo -e "for arg in \"\$@\"; do"
                echo -e "    if [[ \"\$arg\" == \"-h\" || \"\$arg\" == \"--help\" ]]; then"
                echo -e "        echo \"$safe_helptext\""
                echo -e "        exit 0"
                echo -e "    fi"
                echo -e "done"
                tail -n +2 "$script"
            } > "$tmpfile"
            mv "$tmpfile" "$script"
            chmod +x "$script"
            echo "[INFO] -h block generated/added to $script"
        else
            echo "[DEBUG] Invalid shebang for $script, ignored"
        fi
    else
        # Affiche le message uniquement si ce n'est pas un script bash/sh/zsh
        shebang=$(head -n 1 "$script")
        if [[ ! "$shebang" =~ ^#!/bin/(ba|z|)sh ]]; then
            echo "[DEBUG] $script is not an executable file, ignored"
        fi
    fi
    echo "[DEBUG] Finished processing $script"
done

echo "[DEBUG] Finished processing all files"
