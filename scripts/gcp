#!/bin/bash
# Affiche l'aide si -h ou --help est présent n'importe où dans les arguments
for arg in "$@"; do
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        echo "\"Automated git workflow with tests, auto-commit messages via Deepseek, and pushes - options: [-f|--force] [-p|--passtest] [-h|--help]\""
        exit 0
    fi
done


if [ -f .env ]; then
    export $(grep -v '^#' .env | xargs)
fi
if [ -f .env.local ]; then
    export $(grep -v '^#' .env.local | xargs)
fi



function show_usage (){
    printf "Usage: $0 [options ]\n"
    printf "\n"
    printf "Options:\n"
    printf " -f|--force, Force push\n"
    printf " -p|--passtest, Pass tests\n"
    printf " -h|--help, Print help\n"
    
    return 0
}





force=0
passtest=0
message=""

# Charger .env.local uniquement depuis ~/debs ou ~/git/debs (jamais local)
if [ -f "$HOME/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/debs/.env.local" | xargs)
    elif [ -f "$HOME/git/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/git/debs/.env.local" | xargs)
fi

# Parsing des options et récupération du message (premier argument non-option)
while [[ $# -gt 0 ]]; do
    case "$1" in
        --force|-f)
            force=1
            shift
        ;;
        --passtest|-p)
            passtest=1
            shift
        ;;
        --help|-h)
            show_usage
            exit 0
        ;;
        --)
            shift
            ;;
        -* )
            # Option inconnue, ignorer
            shift
            ;;
        *)
            # Premier argument non-option = message
            message="$1"
            shift
    esac
done
# Si d'autres arguments après, les ignorer (ou les concaténer si tu veux gérer un message sur plusieurs mots)
if [[ $# -gt 0 && -z "$message" ]]; then
    message="$*"
fi

if [ ! -d "tests" ]; then
    passtest=1
fi


if [[ $(git status --porcelain) ]] || [ $force == 1 ] ; then
    if [ -f bin/phpunit ] && [ $passtest == 0 ] ; then
        echo "Running tests"
        CURRENT=$(pwd)
        BASENAME=$(basename "$CURRENT")
        docker exec -it "$BASENAME" bin/phpunit
    fi
    if [ $? -ne 0 ]; then
        echo "ERREUR DANS LES TESTS ARRET" && exit
    else
        git add .
        
        # Si pas de message fourni, essayer Deepseek
        if [ -z "$message" ]; then
            if [ -z "$DEEPSEEK" ]; then
                echo "Erreur: ni titre de commit fourni, ni DEEPSEEK dans .env.local."
                exit 1
            fi
            # Générer le diff
            DIFF=$(git diff --cached)
            if [ -z "$DIFF" ]; then
                DIFF=$(git diff)
            fi
            if [ -z "$DIFF" ]; then
                echo "Aucune modification détectée."
                exit 1
            fi
            # Si beaucoup de suppressions/déplacements, ne donner que le nom du dossier
            SUPPR_COUNT=$(echo "$DIFF" | grep -E '^delete mode|^rename ' | wc -l)
            if [ "$SUPPR_COUNT" -gt 10 ]; then
                DIRNAME=$(basename "$PWD")
                echo "[AVERTISSEMENT] Beaucoup de suppressions/déplacements détectées ($SUPPR_COUNT). Seul le nom du dossier sera envoyé à Deepseek."
                DIFF="Suppression ou déplacement massif dans le répertoire : $DIRNAME"
            else
                # Tronquer le diff si trop volumineux
                MAX_DIFF=20000
                if [ ${#DIFF} -gt $MAX_DIFF ]; then
                    echo "[AVERTISSEMENT] Le diff est trop volumineux, il sera tronqué à $MAX_DIFF caractères pour Deepseek."
                    DIFF="${DIFF:0:$MAX_DIFF}\n[...diff tronqué...]"
                fi
            fi
            # ...fin du bloc principal, rien à ajouter ici...
            echo "Génération du commit par Deepseek..."
            # Prompt strict pour forcer une réponse JSON et limiter la taille
            PROMPT="Donne un commit git au format {\"title\":\"...\",\"body\":\"...\"} pour ce diff (max 100 tokens). Réponds uniquement par un objet JSON, rien d'autre. Diff: $DIFF"
            # Utiliser un fichier temporaire pour éviter la limite d'arguments
            TMP_PROMPT=$(mktemp)
            echo -n "$PROMPT" > "$TMP_PROMPT"
            TMP_JSON=$(mktemp)
            # Générer le JSON manuellement pour éviter la limite d'arguments
            printf '{"model": "deepseek-chat", "messages": [{"role": "user", "content": ' > "$TMP_JSON"
            jq -Rs . < "$TMP_PROMPT" >> "$TMP_JSON"
            printf '}]}' >> "$TMP_JSON"
            rm -f "$TMP_PROMPT"
            if [ ! -s "$TMP_JSON" ]; then
                echo "Erreur lors de la préparation du prompt pour Deepseek (json)."
                rm -f "$TMP_JSON"
                exit 1
            fi
            raw_response=$(curl -s -X POST https://api.deepseek.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $DEEPSEEK" \
            --data-binary "@${TMP_JSON}" | jq -r '.choices[0].message.content')
            rm -f "$TMP_JSON"
            # Nettoyer les balises ``` et ```json éventuelles de la réponse Deepseek
            json_commit=$(echo "$raw_response" | tr -d '\r' | tr -d '\n' | sed -E 's/^```json//;s/^```//;s/```$//;s/```//g')
            # Vérifier si la réponse est bien un objet JSON (commence par { et finit par })
            if ! echo "$json_commit" | grep -q '^{.*}$'; then
                echo "Erreur: la réponse Deepseek n'est pas un objet JSON. Réponse brute :"
                echo "$raw_response"
                exit 1
            fi
            commit_title=$(echo "$json_commit" | jq -r '.title')
            commit_body=$(echo "$json_commit" | jq -r '.body')
            if [ -z "$commit_title" ] || [ "$commit_title" == "null" ]; then
                echo "Erreur lors de la génération du message de commit avec Deepseek. Réponse brute :"
                echo "$raw_response"
                exit 1
            fi
            echo "Message de commit généré : $commit_title"
            message="$commit_title"
            # Ajoute le body si présent
            if [ -n "$commit_body" ] && [ "$commit_body" != "null" ]; then
                message="$commit_title\n\n$commit_body"
            fi
        fi
        
        git commit -m "$message"
        git submodule foreach "git add . && gcp '$message'"
        git push --all
        git push --tags
    fi
else
    echo "no modifs ;-)"
fi
            break
        ;;
        -*)
            # Option inconnue, ignorer
            shift
        ;;
        *)
            # Premier argument non-option = message
            message="$1"
            shift
            break
        ;;
    esac
done
# Si d'autres arguments après, les ignorer (ou les concaténer si tu veux gérer un message sur plusieurs mots)
if [[ $# -gt 0 && -z "$message" ]]; then
    message="$*"
fi

if [ ! -d "tests" ]; then
    passtest=1
fi


if [[ $(git status --porcelain) ]] || [ $force == 1 ] ; then
    if [ -f bin/phpunit ] && [ $passtest == 0 ] ; then
        echo "Running tests"
        CURRENT=$(pwd)
        BASENAME=$(basename "$CURRENT")
        docker exec -it "$BASENAME" bin/phpunit
    fi
    if [ $? -ne 0 ]; then
        echo "ERREUR DANS LES TESTS ARRET" && exit
    else
        git add .
        
        # Si pas de message fourni, essayer Deepseek
        if [ -z "$message" ]; then
            if [ -z "$DEEPSEEK" ]; then
                echo "Erreur: ni titre de commit fourni, ni DEEPSEEK dans .env.local."
                exit 1
            fi
            # Générer le diff
            DIFF=$(git diff --cached)
            if [ -z "$DIFF" ]; then
                DIFF=$(git diff)
            fi
            if [ -z "$DIFF" ]; then
                echo "Aucune modification détectée."
                exit 1
            fi
            # Si beaucoup de suppressions/déplacements, ne donner que le nom du dossier
            SUPPR_COUNT=$(echo "$DIFF" | grep -E '^delete mode|^rename ' | wc -l)
            if [ "$SUPPR_COUNT" -gt 10 ]; then
                DIRNAME=$(basename "$PWD")
                echo "[AVERTISSEMENT] Beaucoup de suppressions/déplacements détectées ($SUPPR_COUNT). Seul le nom du dossier sera envoyé à Deepseek."
                DIFF="Suppression ou déplacement massif dans le répertoire : $DIRNAME"
            else
                # Tronquer le diff si trop volumineux
                MAX_DIFF=20000
                if [ ${#DIFF} -gt $MAX_DIFF ]; then
                    echo "[AVERTISSEMENT] Le diff est trop volumineux, il sera tronqué à $MAX_DIFF caractères pour Deepseek."
                    DIFF="${DIFF:0:$MAX_DIFF}\n[...diff tronqué...]"
                fi
            fi
        # ...fin du bloc principal, rien à ajouter ici...
            echo "Génération du commit par Deepseek..."
            # Prompt strict pour forcer une réponse JSON et limiter la taille
            PROMPT="Donne un commit git au format {\"title\":\"...\",\"body\":\"...\"} pour ce diff (max 100 tokens). Réponds uniquement par un objet JSON, rien d'autre. Diff: $DIFF"
            # Utiliser un fichier temporaire pour éviter la limite d'arguments
            TMP_PROMPT=$(mktemp)
            echo -n "$PROMPT" > "$TMP_PROMPT"
            TMP_JSON=$(mktemp)
            # Générer le JSON manuellement pour éviter la limite d'arguments
            printf '{"model": "deepseek-chat", "messages": [{"role": "user", "content": ' > "$TMP_JSON"
            jq -Rs . < "$TMP_PROMPT" >> "$TMP_JSON"
            printf '}]}' >> "$TMP_JSON"
            rm -f "$TMP_PROMPT"
            if [ ! -s "$TMP_JSON" ]; then
                echo "Erreur lors de la préparation du prompt pour Deepseek (json)."
                rm -f "$TMP_JSON"
                exit 1
            fi
            raw_response=$(curl -s -X POST https://api.deepseek.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $DEEPSEEK" \
            --data-binary "@${TMP_JSON}" | jq -r '.choices[0].message.content')
            rm -f "$TMP_JSON"
            # Nettoyer les balises ``` et ```json éventuelles de la réponse Deepseek
            json_commit=$(echo "$raw_response" | tr -d '\r' | tr -d '\n' | sed -E 's/^```json//;s/^```//;s/```$//;s/```//g')
            # Vérifier si la réponse est bien un objet JSON (commence par { et finit par })
            if ! echo "$json_commit" | grep -q '^{.*}$'; then
                echo "Erreur: la réponse Deepseek n'est pas un objet JSON. Réponse brute :"
                echo "$raw_response"
                exit 1
            fi
            commit_title=$(echo "$json_commit" | jq -r '.title')
            commit_body=$(echo "$json_commit" | jq -r '.body')
            if [ -z "$commit_title" ] || [ "$commit_title" == "null" ]; then
                echo "Erreur lors de la génération du message de commit avec Deepseek. Réponse brute :"
                echo "$raw_response"
                exit 1
            fi
            echo "Message de commit généré : $commit_title"
            message="$commit_title"
            # Ajoute le body si présent
            if [ -n "$commit_body" ] && [ "$commit_body" != "null" ]; then
                message="$commit_title\n\n$commit_body"
            fi
        fi
        
        git commit -m "$message"
        git submodule foreach "git add . && gcp '$message'"
    fi
else
    echo "no modifs ;-)"
fi
