if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  echo -e "\nCommit & push git intelligent, message AI si DEEPSEEK, tests, submodules."
  echo "Usage: gcp [message] [--force|-f] [--passtest|-p] [--help|-h]"
  echo "Exemple: gcp 'fix: bug' --force"
  exit 0
fi
#!/bin/bash

function show_usage (){
    printf "Usage: $0 [options ]\n"
    printf "\n"
    printf "Options:\n"
    printf " -f|--force, Force push\n"
    printf " -p|--passtest, Pass tests\n"
    printf " -h|--help, Print help\n"
    
    return 0
}





force=0
passtest=0
message=""

# Charger .env.local uniquement depuis ~/debs ou ~/git/debs (jamais local)
if [ -f "$HOME/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/debs/.env.local" | xargs)
    elif [ -f "$HOME/git/debs/.env.local" ]; then
    export $(grep -v '^#' "$HOME/git/debs/.env.local" | xargs)
fi

# Parsing des options et récupération du message (premier argument non-option)
while [[ $# -gt 0 ]]; do
    case "$1" in
        --force|-f)
            force=1
            shift
        ;;
        --passtest|-p)
            passtest=1
            shift
        ;;
        --help|-h)
            show_usage
            exit 0
        ;;
        --)
            shift
            break
        ;;
        -*)
            # Option inconnue, ignorer
            shift
        ;;
        *)
            # Premier argument non-option = message
            message="$1"
            shift
            break
        ;;
    esac
done
# Si d'autres arguments après, les ignorer (ou les concaténer si tu veux gérer un message sur plusieurs mots)
if [[ $# -gt 0 && -z "$message" ]]; then
    message="$*"
fi

if [ ! -d "tests" ]; then
    passtest=1
fi


if [[ $(git status --porcelain) ]] || [ $force == 1 ] ; then
    if [ -f bin/phpunit ] && [ $passtest == 0 ] ; then
        echo "Running tests"
        CURRENT=$(pwd)
        BASENAME=$(basename "$CURRENT")
        docker exec -it "$BASENAME" bin/phpunit
    fi
    if [ $? -ne 0 ]; then
        echo "ERREUR DANS LES TESTS ARRET" && exit
    else
        git add .
        
        # Si pas de message fourni, essayer Deepseek
        if [ -z "$message" ]; then
            if [ -z "$DEEPSEEK" ]; then
                echo "Erreur: ni titre de commit fourni, ni DEEPSEEK dans .env.local."
                exit 1
            fi
            # Générer le diff
            DIFF=$(git diff --cached)
            if [ -z "$DIFF" ]; then
                DIFF=$(git diff)
            fi
            if [ -z "$DIFF" ]; then
                echo "Aucune modification détectée."
                exit 1
            fi
            # Si beaucoup de suppressions/déplacements, ne donner que le nom du dossier
            SUPPR_COUNT=$(echo "$DIFF" | grep -E '^delete mode|^rename ' | wc -l)
            if [ "$SUPPR_COUNT" -gt 10 ]; then
                DIRNAME=$(basename "$PWD")
                echo "[AVERTISSEMENT] Beaucoup de suppressions/déplacements détectées ($SUPPR_COUNT). Seul le nom du dossier sera envoyé à Deepseek."
                DIFF="Suppression ou déplacement massif dans le répertoire : $DIRNAME"
            else
                # Tronquer le diff si trop volumineux
                MAX_DIFF=20000
                if [ ${#DIFF} -gt $MAX_DIFF ]; then
                    echo "[AVERTISSEMENT] Le diff est trop volumineux, il sera tronqué à $MAX_DIFF caractères pour Deepseek."
                    DIFF="${DIFF:0:$MAX_DIFF}\n[...diff tronqué...]"
                fi
            fi
            echo "Génération du commit par Deepseek..."
            # Prompt pour Deepseek (format JSON, découpe title/body, sans intro ni explication)
            PROMPT="Voici le diff des modifications :\n$DIFF\n\nGénère uniquement et strictement un message de commit git professionnel au format JSON. Réponds exclusivement par l'objet JSON, sans aucune phrase d'introduction, sans analyse, sans explication, sans préambule, sans balise, sans bloc de code, sans texte avant ou après, sans retour à la ligne avant ou après, sans rien d'autre que l'objet JSON. N'inclus surtout pas de balises \`\`\`json ni aucun texte supplémentaire.\n\nFormat attendu : {\"title\": \"feat: courte description\", \"body\": \"explication optionnelle sur plusieurs lignes\"}\n\nExemples : {\"title\": \"feat: ajoute la gestion des utilisateurs\", \"body\": \"Ajout du CRUD utilisateur et des tests associés\"}\n{\"title\": \"fix: corrige le bug d'affichage du menu\", \"body\": \"Correction du CSS pour le menu déroulant\"}\n\nLe champ 'title' doit être court, affirmatif, descriptif, et formaté comme un vrai message de commit. Le champ 'body' est optionnel. La réponse doit être strictement l'objet JSON, rien d'autre."
            # Utiliser un fichier temporaire pour éviter la limite d'arguments
            TMP_PROMPT=$(mktemp)
            echo -n "$PROMPT" > "$TMP_PROMPT"
            TMP_JSON=$(mktemp)
            # Générer le JSON manuellement pour éviter la limite d'arguments
            printf '{"model": "deepseek-chat", "messages": [{"role": "user", "content": ' > "$TMP_JSON"
            jq -Rs . < "$TMP_PROMPT" >> "$TMP_JSON"
            printf '}]}' >> "$TMP_JSON"
            rm -f "$TMP_PROMPT"
            if [ ! -s "$TMP_JSON" ]; then
                echo "Erreur lors de la préparation du prompt pour Deepseek (json)."
                rm -f "$TMP_JSON"
                exit 1
            fi
            raw_response=$(curl -s -X POST https://api.deepseek.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $DEEPSEEK" \
            --data-binary "@${TMP_JSON}" | jq -r '.choices[0].message.content')
            rm -f "$TMP_JSON"
            # Nettoyer les balises ``` et ```json éventuelles de la réponse Deepseek
            json_commit=$(echo "$raw_response" | tr -d '\r' | tr -d '\n' | sed -E 's/^```json//;s/^```//;s/```$//;s/```//g')
            commit_title=$(echo "$json_commit" | jq -r '.title')
            commit_body=$(echo "$json_commit" | jq -r '.body')
            if [ -z "$commit_title" ] || [ "$commit_title" == "null" ]; then
                echo "Erreur lors de la génération du message de commit avec Deepseek. Réponse brute :"
                echo "$raw_response"
                exit 1
            fi
            echo "Message de commit généré : $commit_title"
            message="$commit_title"
            # Ajoute le body si présent
            if [ -n "$commit_body" ] && [ "$commit_body" != "null" ]; then
                message="$commit_title\n\n$commit_body"
            fi
        fi
        
        git commit -m "$message"
        git submodule foreach "git add . && gcp '$message'"
        git add .
        git commit -m "$message"
        git push --all
        git push --tags
    fi
else
    echo "no modifs ;-)"
fi
